# Generated by automation script
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass
from paddleocr import LayoutDetection
from PIL import Image
import numpy as np

class PyTorch_PaddleOCR_LayoutDetection_PPDocLayoutPlusL(PyTorchAbstractClass):
    def __init__(self, config=None):
        self.config = config if config else dict()
        device = self.config.pop("_device", "cpu")
        # multi_gpu is not directly supported by the paddleocr LayoutDetection constructor.
        # We will control GPU usage via the 'use_gpu' parameter.
        use_gpu = True if device == "cuda" else False

        # Parameters for the predict method, from the model card example
        self.batch_size = self.config.get('batch_size', 1)
        self.layout_nms = self.config.get('layout_nms', True)

        # Initialize the PaddleOCR LayoutDetection model
        # The model_name is specific to this wrapper
        self.model = LayoutDetection(model_name="PP-DocLayout_plus-L", use_gpu=use_gpu)

    def preprocess(self, input_images):
        # The model.predict method can directly handle image paths.
        # No tensor conversion is needed.
        return input_images

    def predict(self, model_input):
        # The model.predict method takes a single image path.
        # We will process images one by one in a loop to handle batches.
        results = []
        for image_path in model_input:
            # The output for a single image is a list of LayoutResult objects (one per page)
            output = self.model.predict(image_path, batch_size=self.batch_size, layout_nms=self.layout_nms)
            results.append(output)
        return results

    def postprocess(self, model_output):
        # model_output is a list of lists, where each inner list contains LayoutResult objects for an image.
        # e.g., [[LayoutResult_img1_page1], [LayoutResult_img2_page1]]
        # Each LayoutResult object contains the detected boxes for a page.
        processed_outputs = []
        for image_results in model_output:  # Iterate through results for each image
            # For a standard image, there's usually one LayoutResult object in the list
            if not image_results:
                processed_outputs.append([])
                continue

            # We process the first page/result object for simplicity
            layout_result = image_results[0]

            # The layout_result object behaves like a list of dictionaries for each detected box
            boxes = []
            for box_info in layout_result:
                boxes.append({
                    'label': box_info['label'],
                    'score': float(box_info['score']),  # Ensure score is a standard Python float
                    'coordinate': box_info['coordinate'].tolist() if isinstance(box_info['coordinate'], np.ndarray) else box_info['coordinate']
                })
            processed_outputs.append(boxes)
        return processed_outputs
