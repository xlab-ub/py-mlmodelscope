# Generated by automation script
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass
from paddleocr import FormulaRecognition
from PIL import Image

class PyTorch_PaddleOCR_PP_FormulaNet_Plus_L(PyTorchAbstractClass):
    def __init__(self, config=None):
        self.config = config if config else dict()
        device = self.config.pop("_device", "cpu")
        # multi_gpu is not directly supported by this wrapper, device selection is handled by use_gpu
        multi_gpu = self.config.pop("_multi_gpu", False)
        use_gpu = True if device == "cuda" else False

        # The paddleocr library handles model downloading and caching.
        # The model_name parameter is used to specify which pre-trained model to use.
        self.model = FormulaRecognition(model_name="PaddlePaddle/PP-FormulaNet_plus-L", use_gpu=use_gpu)

        self.batch_size = self.config.get('batch_size', 1)

    def preprocess(self, input_images):
        # The paddleocr library's predict method directly accepts a list of image file paths.
        # No image loading or tensor conversion is necessary in this step.
        return input_images

    def predict(self, model_input):
        # The model_input is a list of image paths from the preprocess step.
        return self.model.predict(input=model_input, batch_size=self.batch_size)

    def postprocess(self, model_output):
        # The model output is a list of result objects.
        # Each object contains a dictionary with the key 'res', which in turn contains 'rec_formula'.
        # We extract the 'rec_formula' string (the LaTeX code) from each result.
        captions = [res['res']['rec_formula'] for res in model_output if res and 'res' in res and 'rec_formula' in res['res']]
        return captions
