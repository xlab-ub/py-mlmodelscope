# Generated by automation script
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass
from paddleocr import TextRecognition
from PIL import Image

class PyTorch_PaddleOCR_PP_OCRv5_Server_Rec(PyTorchAbstractClass):
    def __init__(self, config=None):
        self.config = config if config else dict()
        device = self.config.pop("_device", "cpu")
        multi_gpu = self.config.pop("_multi_gpu", False)

        use_gpu = True if "cuda" in device else False
        gpu_id = 0
        if use_gpu and ":" in device:
            try:
                gpu_id = int(device.split(":")[1])
            except (ValueError, IndexError):
                gpu_id = 0

        # The paddleocr library is used here, not Hugging Face Transformers
        # It handles model downloading and caching internally.
        self.model = TextRecognition(
            model_name="PaddlePaddle/PP-OCRv5_server_rec",
            use_gpu=use_gpu,
            gpu_id=gpu_id
        )

        self.batch_size = self.config.get('batch_size', 1)

    def preprocess(self, input_images):
        # The paddleocr model's predict method can directly accept a list of image file paths.
        # Therefore, no image loading or tensor conversion is necessary in this step.
        # We just pass the list of paths through.
        return input_images

    def predict(self, model_input):
        # The model_input is the list of image paths from the preprocess step.
        # The model handles batching internally via the batch_size parameter.
        return self.model.predict(input=model_input, batch_size=self.batch_size)

    def postprocess(self, model_output):
        # The model output is a list of TextRecognitionResult objects.
        # Each object has a 'res' attribute which is a dictionary containing the recognized text and score.
        # We extract the 'rec_text' from each result.
        preds = [result.res['rec_text'] for result in model_output]
        return [pred.strip() for pred in preds]
