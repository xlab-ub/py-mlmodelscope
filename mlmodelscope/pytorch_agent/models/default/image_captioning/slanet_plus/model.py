# Generated by automation script
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass
from paddleocr import TableStructureRecognition
from PIL import Image

class PyTorch_PaddleOCR_SLANet_Plus_Table_Structure_Recognition(PyTorchAbstractClass):
    def __init__(self, config=None):
        self.config = config if config else dict()
        # Device and multi_gpu are not directly used by paddleocr's TableStructureRecognition constructor
        # but we keep the boilerplate for interface consistency.
        # The underlying engine might pick up CUDA_VISIBLE_DEVICES.
        device = self.config.pop("_device", "cpu")
        multi_gpu = self.config.pop("_multi_gpu", False)

        # The model_name parameter loads the specific model from the paddleocr library.
        self.model = TableStructureRecognition(model_name="SLANet_plus")

        # Get batch_size from config, default to 1 as in the example
        self.batch_size = self.config.get('batch_size', 1)

    def preprocess(self, input_images):
        # The paddleocr predict method directly accepts a list of image file paths.
        # No further preprocessing like opening with PIL or converting to tensors is needed.
        return input_images

    def predict(self, model_input):
        # The model_input is a list of image paths from the preprocess step.
        return self.model.predict(input=model_input, batch_size=self.batch_size)

    def postprocess(self, model_output):
        # The model_output is a list of result objects from paddleocr.
        # Each object contains a dictionary with the key 'res', which in turn contains 'structure'.
        # The 'structure' is a list of HTML tags. We join them to form the final caption.
        captions = []
        for result in model_output:
            # The result object from paddleocr contains the structured data.
            # Based on the print output, the structure is nested.
            if result and 'res' in result and 'structure' in result['res']:
                html_structure = result['res']['structure']
                captions.append("".join(html_structure))
            else:
                captions.append("")  # Append empty string if structure is not found
        return captions
