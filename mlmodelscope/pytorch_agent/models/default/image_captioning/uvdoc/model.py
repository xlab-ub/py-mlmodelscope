# Generated by automation script
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass
from paddleocr import TextImageUnwarping
from PIL import Image
import os
import numpy as np

class PyTorch_PaddleOCR_UVDoc_Image_Unwarping(PyTorchAbstractClass):
    def __init__(self, config=None):
        self.config = config if config else dict()
        # This model is from PaddleOCR, not PyTorch/Transformers, so device/multi_gpu are not directly applicable
        # but we keep the structure for compatibility with the runner.
        device = self.config.pop("_device", "cpu")
        multi_gpu = self.config.pop("_multi_gpu", False)

        # Load the PaddleOCR TextImageUnwarping model
        # The model identifier 'PaddlePaddle/UVDoc' corresponds to model_name='UVDoc'
        self.model = TextImageUnwarping(model_name="UVDoc")

        # Get parameters from config
        self.batch_size = self.config.get('batch_size', 1)
        self.output_dir = self.config.get('output_dir', './unwarped_images')

    def preprocess(self, input_images):
        # The model's predict method takes a list of image paths directly.
        # No image loading or tensor conversion is needed here.
        return input_images

    def predict(self, model_input):
        # The model_input is a list of image paths from the preprocess step.
        # The predict method handles image loading and processing internally.
        return self.model.predict(model_input, batch_size=self.batch_size)

    def postprocess(self, model_output):
        # The model_output is a list of result objects from PaddleOCR.
        # This model performs document unwarping, not captioning.
        # We will save the unwarped image and return its path as the result.
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)

        output_paths = []
        for res in model_output:
            # The result object contains the unwarped image as a numpy array
            # under res.res['doctr_img']
            unwarped_img_array = res.res['doctr_img']

            # Convert numpy array to a PIL Image
            # The array is likely in BGR format from OpenCV, so convert to RGB
            if unwarped_img_array.ndim == 3 and unwarped_img_array.shape[2] == 3:
                unwarped_img_array = unwarped_img_array[:, :, ::-1] # BGR to RGB
            pil_image = Image.fromarray(unwarped_img_array.astype(np.uint8))

            # Create an output path based on the input file name
            input_filename = os.path.basename(res.res['input_path'])
            save_path = os.path.join(self.output_dir, f"unwarped_{input_filename}")

            # Save the image
            pil_image.save(save_path)
            output_paths.append(save_path)

        return output_paths
