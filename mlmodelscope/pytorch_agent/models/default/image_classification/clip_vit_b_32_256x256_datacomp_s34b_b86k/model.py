# Generated by automation script
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

import torch
from PIL import Image
import open_clip
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

class PyTorch_OpenCLIP_ViT_B_32_256x256(PyTorchAbstractClass):
    def __init__(self, config=None):
        super().__init__(config)
        model_id = 'laion/CLIP-ViT-B-32-256x256-DataComp-s34B-b86K'
        
        self.model, _, self.preprocess_transform = open_clip.create_model_and_transforms(f'hf-hub:{model_id}')
        self.tokenizer = open_clip.get_tokenizer(f'hf-hub:{model_id}')
        self.model.eval()

        # Download ImageNet classes for zero-shot classification
        features_file_url = "http://s3.amazonaws.com/store.carml.org/synsets/imagenet/synset.txt"
        self.features = self.features_download(features_file_url)
        
        # Pre-compute text features for the classes
        text_inputs = self.tokenizer(self.features)
        with torch.no_grad():
            text_features = self.model.encode_text(text_inputs)
            text_features /= text_features.norm(dim=-1, keepdim=True)
            self.text_features = text_features.to(self.device)
        
        self.model.to(self.device)

    def preprocess(self, input_images):
        processed_images = [self.preprocess_transform(Image.open(image_path).convert('RGB')) for image_path in input_images]
        model_input = torch.stack(processed_images)
        return model_input

    def predict(self, model_input):
        with torch.no_grad():
            image_features = self.model.encode_image(model_input.to(self.device))
            image_features /= image_features.norm(dim=-1, keepdim=True)
            
            # Cosine similarity as logits
            logits_per_image = self.model.logit_scale.exp() * image_features @ self.text_features.T
            
            return logits_per_image

    def postprocess(self, model_output):
        probabilities = torch.nn.functional.softmax(model_output, dim=1)
        return probabilities.tolist()
