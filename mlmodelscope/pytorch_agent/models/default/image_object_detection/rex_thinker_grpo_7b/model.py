# Generated by automation script
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

import torch
from transformers import AutoProcessor, AutoModelForCausalLM
from PIL import Image
import json
import re

class PyTorch_Transformers_RexThinkerGRPO7B(PyTorchAbstractClass):
    def __init__(self):
        super().__init__(config)
        model_id = "IDEA-Research/Rex-Thinker-GRPO-7B"
        self.processor = AutoProcessor.from_pretrained(model_id, trust_remote_code=True)
        self.load_hf_model(AutoModelForCausalLM, model_id, torch_dtype=torch.bfloat16, trust_remote_code=True)

    def preprocess(self, input_images):
        # This model requires a text prompt along with the image, passed via kwargs.
        text_prompts = kwargs.get("text_prompts")
        if not text_prompts or len(text_prompts) != len(input_images):
            raise ValueError("A list of 'text_prompts' with the same length as input_images must be provided via kwargs.")

        images = [Image.open(p).convert("RGB") for p in input_images]
        
        messages = [
            [{"role": "user", "content": f"<image>\n{prompt}"}]
            for prompt in text_prompts
        ]
        prompts = [self.processor.apply_chat_template(msg, tokenize=False, add_generation_prompt=True) for msg in messages]

        model_input = self.processor(text=prompts, images=images, return_tensors="pt").to(self.device)
        return model_input

    def predict(self, model_input):
        return self.model.generate(**model_input, max_new_tokens=1024, do_sample=False)

    def postprocess(self, model_output):
        decoded_text = self.processor.batch_decode(model_output, skip_special_tokens=True)[0]
        scores, labels, boxes = [], [], []
        match = re.search(r"<answer>json\\n(.*?)</answer>", decoded_text, re.DOTALL)
        if match:
            try:
                json_str = match.group(1).strip()
                detections = json.loads(json_str)
                for det in detections:
                    if 'bbox_2d' in det:
                        boxes.append(det['bbox_2d'])
                        labels.append(1)
                        scores.append(1.0)
            except (json.JSONDecodeError, IndexError):
                pass
        return [scores], [labels], [boxes]
