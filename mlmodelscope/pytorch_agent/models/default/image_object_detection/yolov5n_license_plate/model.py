# Generated by automation script
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

import yolov5
from PIL import Image

class PyTorch_YOLOv5_LicensePlate(PyTorchAbstractClass):
    def __init__(self, config=None):
        self.config = config if config else dict()
        device = self.config.pop("_device", "cpu")
        multi_gpu = self.config.pop("_multi_gpu", False)

        self.model = yolov5.load('keremberke/yolov5n-license-plate', device=device)

        # Set model parameters from config or use defaults from the model card
        self.model.conf = self.config.get("conf", 0.25)
        self.model.iou = self.config.get("iou", 0.45)
        self.model.agnostic = self.config.get("agnostic", False)
        self.model.multi_label = self.config.get("multi_label", False)
        self.model.max_det = self.config.get("max_det", 1000)

    def preprocess(self, input_images):
        # The model accepts a list of image paths or PIL images directly
        return input_images

    def predict(self, model_input):
        # Extract inference size from config, default to 640
        size = self.config.get("size", 640)
        return self.model(model_input, size=size)

    def postprocess(self, model_output):
        # The yolov5 results object contains a .pred attribute, which is a list of tensors.
        # Each tensor corresponds to the predictions for an image.
        # Format: [x1, y1, x2, y2, confidence, class]
        all_scores = []
        all_labels = []
        all_boxes = []

        for predictions in model_output.pred:
            all_boxes.append(predictions[:, :4].tolist())
            all_scores.append(predictions[:, 4].tolist())
            all_labels.append(predictions[:, 5].tolist())

        return all_scores, all_labels, all_boxes
