# Generated by automation script
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

import yolov5
import torch

class PyTorch_Yolov5_keremberke_yolov5s_license_plate(PyTorchAbstractClass):
    def __init__(self, config=None):
        self.config = config if config else dict()
        device = self.config.pop("_device", "cpu")
        multi_gpu = self.config.pop("_multi_gpu", False)

        self.model = yolov5.load('keremberke/yolov5s-license-plate', device=device)

        # Set model parameters from the Hugging Face example
        self.model.conf = 0.25  # NMS confidence threshold
        self.model.iou = 0.45  # NMS IoU threshold
        self.model.agnostic = False  # NMS class-agnostic
        self.model.multi_label = False  # NMS multiple labels per box
        self.model.max_det = 1000  # maximum number of detections per image

    def preprocess(self, input_images):
        # The yolov5 model directly accepts image paths
        return input_images

    def predict(self, model_input):
        # The model call handles preprocessing and inference
        # The size parameter is specified in the model card
        return self.model(model_input, size=640)

    def postprocess(self, model_output):
        # The model output object has a .pred attribute which is a list of tensors
        # We assume a batch size of 1, so we take the first element
        predictions = model_output.pred[0]
        
        boxes = predictions[:, :4].tolist()  # x1, y1, x2, y2
        scores = predictions[:, 4].tolist()
        labels = predictions[:, 5].tolist()
        
        # The expected output is a tuple of lists, where each list contains results for one image
        return [scores], [labels], [boxes]
