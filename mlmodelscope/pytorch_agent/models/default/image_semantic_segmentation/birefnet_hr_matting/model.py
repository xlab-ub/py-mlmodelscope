# Generated by automation script
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

import torch
from transformers import AutoModelForImageSegmentation
from PIL import Image
from torchvision import transforms

class PyTorch_Transformers_BiRefNet_HR_matting(PyTorchAbstractClass):
    def __init__(self, config=None):
        self.config = config if config else dict()
        device = self.config.pop("_device", "cpu")
        multi_gpu = self.config.pop("_multi_gpu", False)
        model_id = 'ZhengPeng7/BiRefNet_HR-matting'

        image_size = self.config.get("image_size", (2048, 2048))
        self.preprocessor = transforms.Compose([
            transforms.Resize(image_size),
            transforms.ToTensor(),
            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
        ])

        if multi_gpu and device == "cuda":
            self.model = AutoModelForImageSegmentation.from_pretrained(model_id, trust_remote_code=True, device_map="auto", torch_dtype="auto")
        else:
            self.model = AutoModelForImageSegmentation.from_pretrained(model_id, trust_remote_code=True)

    def preprocess(self, input_images):
        processed_images = []
        for image_path in input_images:
            image = Image.open(image_path).convert("RGB")
            processed_image = self.preprocessor(image)
            processed_images.append(processed_image)
        model_input = torch.stack(processed_images)
        return model_input

    def predict(self, model_input):
        return self.model(model_input)

    def postprocess(self, model_output):
        # The model returns a tuple of outputs; the last one is the main prediction.
        # It's a logit, so we apply sigmoid to get probabilities.
        preds = model_output[-1].sigmoid()
        # Threshold at 0.5 to get a binary mask and remove the channel dimension.
        binary_mask = (preds > 0.5).squeeze(1).int()
        return binary_mask.tolist()
