# Generated by automation script
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

import torch
from transformers import AutoModelForImageSegmentation
from PIL import Image
from torchvision import transforms
import warnings

class PyTorch_Transformers_Cocktailpeanut_RM(PyTorchAbstractClass):
    def __init__(self, config=None):
        self.config = config if config else dict()
        device = self.config.pop("_device", "cpu")
        multi_gpu = self.config.pop("_multi_gpu", False)
        model_id = "cocktailpeanut/rm"

        warnings.warn("If the size of the images is not consistent, the batch size should be 1.")

        # This model uses a custom preprocessing pipeline defined in its usage example
        image_size = (1024, 1024)
        self.transform = transforms.Compose([
            transforms.Resize(image_size),
            transforms.ToTensor(),
            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
        ])

        if multi_gpu and device == "cuda":
            self.model = AutoModelForImageSegmentation.from_pretrained(model_id, trust_remote_code=True, device_map="auto", torch_dtype="auto")
        else:
            self.model = AutoModelForImageSegmentation.from_pretrained(model_id, trust_remote_code=True)
        
        self.model.eval()

    def preprocess(self, input_images):
        processed_images = []
        for image_path in input_images:
            image = Image.open(image_path).convert('RGB')
            processed_images.append(self.transform(image))
        model_input = torch.stack(processed_images)
        return model_input

    def predict(self, model_input):
        return self.model(model_input)

    def postprocess(self, model_output):
        # The model returns a tuple, and the segmentation map is the last element.
        # We apply a sigmoid to get probabilities and then threshold at 0.5 for a binary mask.
        preds = model_output[-1].sigmoid()
        binary_mask = (preds > 0.5).squeeze(1).int()
        return binary_mask.tolist()
