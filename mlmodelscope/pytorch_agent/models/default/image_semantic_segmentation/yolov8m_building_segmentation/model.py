# Generated by automation script
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass
from ultralyticsplus import YOLO
import torch

class PyTorch_UltralyticsPlus_YOLOv8m_BuildingSegmentation(PyTorchAbstractClass):
    def __init__(self, config=None):
        self.config = config if config else dict()
        device = self.config.pop("_device", "cpu")
        multi_gpu = self.config.pop("_multi_gpu", False)

        model_id = 'keremberke/yolov8m-building-segmentation'
        self.model = YOLO(model_id)

        # Set common ultralytics parameters from config
        overrides = {k: v for k, v in self.config.items() if k in ['conf', 'iou', 'agnostic_nms', 'max_det']}
        self.model.overrides.update(overrides)

    def preprocess(self, input_images):
        # The YOLO model from ultralyticsplus can directly handle image paths.
        return input_images

    def predict(self, model_input):
        # The model.predict method handles preprocessing, inference, and initial postprocessing.
        return self.model.predict(model_input)

    def postprocess(self, model_output):
        final_masks = []
        for result in model_output:
            # result is a Results object from ultralytics
            if result.masks is not None and len(result.masks) > 0:
                # This is an instance segmentation model with one class ('Building').
                # We convert the instance masks to a single semantic mask by merging them.
                # result.masks.data is a tensor of shape [num_instances, height, width]
                # Summing along dim=0 and clamping to 1 merges all instance masks.
                semantic_mask = torch.sum(result.masks.data, dim=0).clamp(0, 1).long()
                final_masks.append(semantic_mask.tolist())
            else:
                # If no masks are found, return an empty mask of the original image size.
                h, w = result.orig_shape
                empty_mask = torch.zeros((h, w), dtype=torch.long)
                final_masks.append(empty_mask.tolist())
        return final_masks
