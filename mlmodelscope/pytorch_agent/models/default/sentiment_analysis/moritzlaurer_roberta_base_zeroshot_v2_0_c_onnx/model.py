# Generated by automation script
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

from transformers import pipeline
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

class PyTorch_Transformers_Roberta_ZeroShot_ONNX(PyTorchAbstractClass):
    def __init__(self, config=None):
        self.config = config if config else dict()
        device = self.config.pop("_device", "cpu")
        multi_gpu = self.config.pop("_multi_gpu", False)

        # The pipeline handles device mapping, we'll pass the primary device index
        device_id = 0 if device.startswith("cuda") else -1

        # The candidate_labels for zero-shot classification must be provided in the config.
        self.candidate_labels = self.config.get("candidate_labels")
        if not self.candidate_labels:
            print("Warning: 'candidate_labels' not found in config. Zero-shot classification requires a list of labels, e.g., config={'candidate_labels': ['politics', 'sports']}.")
            self.candidate_labels = []

        # This model is an ONNX model. The transformers pipeline can use it
        # if the 'optimum' and 'onnxruntime' (or 'onnxruntime-gpu') libraries are installed.
        model_id = "protectai/MoritzLaurer-roberta-base-zeroshot-v2.0-c-onnx"
        
        self.classifier = pipeline(
            "zero-shot-classification",
            model=model_id,
            device=device_id
        )
        
        self.features = self.candidate_labels

    def preprocess(self, input_texts):
        # The pipeline takes raw text, so no tokenization is needed here.
        return input_texts

    def predict(self, model_input):
        # model_input is a list of raw texts from the preprocess method.
        # The pipeline requires candidate_labels, which are set during initialization from the config.
        if not self.candidate_labels:
            raise ValueError("Cannot run prediction without 'candidate_labels'. Please provide them in the config during model initialization.")
        return self.classifier(model_input, candidate_labels=self.candidate_labels)

    def postprocess(self, model_output):
        # The pipeline output is already a list of dictionaries with labels and scores.
        return model_output
