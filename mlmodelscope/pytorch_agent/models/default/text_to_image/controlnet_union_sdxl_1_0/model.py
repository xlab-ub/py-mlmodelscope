# Generated by automation script
from mlmodelscope.pytorch_agent.models.pytorch_abc import PyTorchAbstractClass

import torch
from diffusers import ControlNetModel, StableDiffusionXLControlNetPipeline, AutoencoderKL
from diffusers.utils import load_image
import numpy as np
from PIL import Image

class PyTorch_Diffusers_ControlNetUnion_SDXL_1_0(PyTorchAbstractClass):
    def __init__(self, config=None):
        self.config = config if config else dict()
        device = self.config.pop("_device", "cpu")
        multi_gpu = self.config.pop("_multi_gpu", False)

        dtype = torch.float16 if multi_gpu and device == "cuda" else torch.float32

        controlnet = ControlNetModel.from_pretrained(
            "xinsir/controlnet-union-sdxl-1.0",
            torch_dtype=dtype
        )
        vae = AutoencoderKL.from_pretrained("madebyollin/sdxl-vae-fp16-fix", torch_dtype=dtype)
        
        self.pipeline = StableDiffusionXLControlNetPipeline.from_pretrained(
            "stabilityai/stable-diffusion-xl-base-1.0",
            controlnet=controlnet,
            vae=vae,
            torch_dtype=dtype
        )
        self.num_inference_steps = self.config.get('num_inference_steps', 30)

    def preprocess(self, input_prompts):
        # input_prompts is a list of dicts, e.g., [{'prompt': '...', 'image_url': '...'}]
        prompts = [item['prompt'] for item in input_prompts]
        # 'image_url' can be a local path or a web URL
        conditioning_images = [load_image(item['image_url']).convert("RGB") for item in input_prompts]
        return {"prompt": prompts, "image": conditioning_images}

    def predict(self, model_input):
        # model_input is a dict with 'prompt' and 'image' keys
        return self.pipeline(**model_input, num_inference_steps=self.num_inference_steps).images

    def postprocess(self, model_output):
        import numpy as np
        return [np.array(img).tolist() for img in model_output]

    def to(self, device):
        self.device = device
        self.pipeline.to(device)

    def eval(self):
        pass
